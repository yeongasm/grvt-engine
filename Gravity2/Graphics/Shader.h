#pragma once


/**
* Shader creation data structure.
* Provide information for shader generation.
* All Shaders created require a name for identification. Failing to provide a name would cause Gravity to abort it's shader generation process.
* NOTE: Gravity will exit from it's shader creation process if one of the requirements fails.
*
* @param [REQUIRED] (String) name			- Name to be given to this shader.
* @param [REQUIRED] (String) vertexShader	- Name of vertex shader file.
* @param [REQUIRED] (String) fragmentShader	- Name of fragment shader file.
* @param [OPTIONAL] (String) geometryShader	- Name of geometry shader file.
* @param [REQUIRED] (String) directory		- Path to the files.
*/
struct ShaderCreationInfo {

	String Name;
	String VertexShader;
	String FragmentShader;
	String GeometryShader;
	String Directory;

};


/**
* Gravity engine's wrapper for OpenGL vertex attribute and shader uniform types.
*/
enum AttrType {
	ATTR_TYPE_NONE,
	ATTR_TYPE_BOOL,
	ATTR_TYPE_INT,
	ATTR_TYPE_FLOAT,
	ATTR_TYPE_SAMPLER,
	ATTR_TYPE_VECTOR,
	ATTR_TYPE_MATRIX
};


enum AttrSubType {
	ATTR_SUB_NONE,
	ATTR_SUB_SAMPLER1D,
	ATTR_SUB_SAMPLER2D,
	ATTR_SUB_SAMPLER3D,
	ATTR_SUB_SAMPLERCUBE,
	ATTR_SUB_VEC2,
	ATTR_SUB_VEC3,
	ATTR_SUB_VEC4,
	ATTR_SUB_MAT2,
	ATTR_SUB_MAT3,
	ATTR_SUB_MAT4
};


struct VertexAttr {

	String		Name;
	AttrType	Type;
	AttrSubType SubType;
	uint		Location;
	int			Size;

	VertexAttr() : size(-1), location(-1), type(ATTR_TYPE_NONE), subType(ATTR_SUB_NONE) {}
};

struct UniformAttr {
public:
	bool		inUse;
	int			size;
	uint		location;
	AttrType	type;
	AttrSubType subType;
	String		name;

	union {
		bool		boolean;
		int			integer;
		float		floating;
		glm::vec2	vec2;
		glm::vec3	vec3;
		glm::vec4	vec4;
		glm::mat2	mat2;
		glm::mat3	mat3;
		glm::mat4	mat4;
	};

	UniformAttr() : inUse(false), size(-1), location(-1), type(ATTR_TYPE_NONE), subType(ATTR_SUB_NONE) {}

	/**
	* Retrieve the value of the uniform by specifying it's type from the Shader.
	*/
	template <class T> inline T Cast() {
		return *((T*)&boolean);
	}

	/**
	* Updates the value of the specified uniform.
	*/
	template <class T>
	bool UpdateValue(const T &Value) {
		if (Cast<T>() == Value)
			return false;

		//Cast<T>() = Value;
		*((T*)&boolean) = Value;

		//Changed = true;

		return true;
	}
};


/**
* Gravity engine's wrapper for OpenGL vertex attributes and shader uniforms.
* Vertex attributes from shader are not meant to be changed but is available for references.
* Shader uniforms are stored as a single union with types bool, int, float, vec2, vec3, vec4, mat2, mat3 and mat4.
* NOTE: Uniform types must be known!
*
* To update a value of a uniform, call UpdateValue() and specify the uniform's type inside the template specifier.
* To use a value of a uniform, call Cast() and specify the uniform's type inside the template specifier.
*/
struct ShaderAttr {
	
	std::map<String, VertexAttr>	Attributes;
	std::map<String, UniformAttr>	Uniforms;

	ShaderAttr();
	~ShaderAttr();

	ShaderAttr(const ShaderAttr &Other);
	ShaderAttr& operator= (const ShaderAttr &Other);

	ShaderAttr(ShaderAttr &&Other);
	ShaderAttr& operator= (ShaderAttr &&Other);

};

// Forward declaration of the struct.
struct ShaderData;
struct MaterialObj;

/**
* Gravity engine's shader data structure.
* All of Gravity's shader objects are required to be of pointer-type.
*
* @param [GENERATED] (uint)		id	 - Program id generated by OpenGL upon shader creation.
* @param [GENERATED] (String)	name - Shader's name is equivalent to the name given in ShaderCreationInfo.
*
* TODO(Afiq):
* The shader class needs to be revamped as a whole. This class should only be an abstraction layer for an id that's the actual shaders.
*/
class ShaderObj {
private:

	enum ShaderType {
		SHADER_TYPE_VERTEX		= 0x8B31,
		SHADER_TYPE_FRAGMENT	= 0x8B30,
		SHADER_TYPE_GEOMETRY	= 0x8DD9
	};

	void		DeleteShader		(const std::initializer_list<uint> &IDs);
	bool		CompileShader		(uint &ID, const char *Source, ShaderType Type);
	void		GetAttributeType	(uint Type, AttrType &Main, AttrSubType &Sub);

	using UniformArr = Array<UniformAttr>;
	using VertAttArr = Array<VertexAttr>;

public:

	uint		Id;
	ShaderData	*Info;
	ShaderAttr	Attributes;

	ShaderObj();
	~ShaderObj();

	ShaderObj(const ShaderCreationInfo &Info);

	ShaderObj(const ShaderObj &Other)					= delete;
	ShaderObj& operator= (const ShaderObj &Other)		= delete;

	ShaderObj(ShaderObj &&Other);
	ShaderObj& operator= (ShaderObj &&Other);

	bool		Alloc				(const ShaderCreationInfo &Info);
	void		Free				();
	void		RetrieveAttributes	(ShaderAttr *Buff);

	bool		IsUniformAMaterial	(const UniformAttr &Uniform);

	void		Use					();
	void		SetInt				(const char *Uniform, int Value);
	void		SetInt				(const UniformAttr &Uniform);
	void		SetBool				(const char *Uniform, bool Value);
	void		SetBool				(const UniformAttr &Uniform);
	void		SetFloat			(const char *Uniform, float Value);
	void		SetFloat			(const UniformAttr &Uniform);
	void		SetVector			(const char *Uniform, glm::vec2 Value);
	void		SetVector			(const char *Uniform, glm::vec3 Value);
	void		SetVector			(const char *Uniform, glm::vec4 Value);
	void		SetVector			(const UniformAttr &Uniform);
	void		SetMatrix			(const char *Uniform, glm::mat2 Value);
	void		SetMatrix			(const char *Uniform, glm::mat3 Value);
	void		SetMatrix			(const char *Uniform, glm::mat4 Value);
	void		SetMatrix			(const UniformAttr &Uniform);
	//void		SetMaterial			(const Material *Material);
	void		SetUniform			(const UniformAttr &Uniform);
};