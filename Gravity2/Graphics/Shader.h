#pragma once


/**
* Shader creation data structure.
* Provide information for shader generation.
* All Shaders created require a name for identification. Failing to provide a name would cause Gravity to abort it's shader generation process.
* NOTE: Gravity will exit from it's shader creation process if one of the requirements fails.
*
* @param [REQUIRED] (String) name			- Name to be given to this shader.
* @param [REQUIRED] (String) vertexShader	- Name of vertex shader file.
* @param [REQUIRED] (String) fragmentShader	- Name of fragment shader file.
* @param [OPTIONAL] (String) geometryShader	- Name of geometry shader file.
* @param [REQUIRED] (String) directory		- Path to the files.
*/
struct ShaderCreationInfo {

	String Name;
	String VertexPath;
	String FragmentPath;
	String GeometryPath;

	ShaderCreationInfo();
	~ShaderCreationInfo();

};


/**
* Gravity engine's wrapper for OpenGL vertex attribute and shader uniform types.
*/
enum AttrType {

	ATTR_TYPE_NONE,
	ATTR_TYPE_BOOL,
	ATTR_TYPE_INT,
	ATTR_TYPE_FLOAT,
	ATTR_TYPE_SAMPLER,
	ATTR_TYPE_VECTOR,
	ATTR_TYPE_MATRIX

};


enum AttrSubType {

	ATTR_SUBTYPE_NONE,
	ATTR_SUBTYPE_SAMPLER1D,
	ATTR_SUBTYPE_SAMPLER2D,
	ATTR_SUBTYPE_SAMPLER3D,
	ATTR_SUBTYPE_SAMPLERCUBE,
	ATTR_SUBTYPE_VEC2,
	ATTR_SUBTYPE_VEC3,
	ATTR_SUBTYPE_VEC4,
	ATTR_SUBTYPE_MAT2,
	ATTR_SUBTYPE_MAT3,
	ATTR_SUBTYPE_MAT4

};


struct VertexAttr {

	String		Name;
	AttrType	Type;
	AttrSubType SubType;
	uint		Location;
	int			Size;

	VertexAttr();
	~VertexAttr();

};

class UniformAttr : public VertexAttr {
private:

	union {
		bool		Boolean;
		int			Integer;
		float		Float;
		glm::vec2	Vec2;
		glm::vec3	Vec3;
		glm::vec4	Vec4;
		glm::mat2	Mat2;
		glm::mat3	Mat3;
		glm::mat4	Mat4;
	};

public:
	
	UniformAttr();
	~UniformAttr();

	/**
	* Retrieve the value of the uniform by specifying it's type from the Shader.
	*/
	template <class T> inline T Cast() {
		return *((T*)&Boolean);
	}

	/**
	* Updates the value of the specified uniform.
	*/
	template <class T>
	bool UpdateValue(const T &Value) {
		if (Cast<T>() == Value)
			return false;

		*((T*)&Boolean) = Value;

		return true;
	}
};


/**
* Gravity engine's wrapper for OpenGL vertex attributes and shader uniforms.
* Vertex attributes from shader are not meant to be changed but is available for references.
* Shader uniforms are stored as a single union with types bool, int, float, vec2, vec3, vec4, mat2, mat3 and mat4.
* NOTE: Uniform types must be known!
*
* To update a value of a uniform, call UpdateValue() and specify the uniform's type inside the template specifier.
* To use a value of a uniform, call Cast() and specify the uniform's type inside the template specifier.
*/
struct ShaderVar {
	
	std::map<String, VertexAttr>	Attributes;
	std::map<String, UniformAttr>	Uniforms;

	ShaderVar();
	~ShaderVar();

	ShaderVar(const ShaderVar &Other);
	ShaderVar& operator= (const ShaderVar &Other);

	ShaderVar(ShaderVar &&Other);
	ShaderVar& operator= (ShaderVar &&Other);

};

// Forward declaration of the struct.
struct ShaderData;
struct MaterialObj;

/**
* Gravity engine's shader data structure.
* All of Gravity's shader objects are required to be of pointer-type.
*
* @param [GENERATED] (uint)		id	 - Program id generated by OpenGL upon shader creation.
* @param [GENERATED] (String)	name - Shader's name is equivalent to the name given in ShaderCreationInfo.
*
* TODO(Afiq):
* The shader class needs to be revamped as a whole. This class should only be an abstraction layer for an id that's the actual shaders.
*/
class ShaderObj {
private:

	void		DeleteShader		(const std::initializer_list<uint> &IDs);
	bool		CompileShader		(uint &ID, const char *Source);
	void		GetAttributeType	(uint Type, AttrType &Main, AttrSubType &Sub);

public:

	uint		Id;
	ShaderData	*Info;
	ShaderVar	Variables;

	ShaderObj();
	~ShaderObj();

	ShaderObj(const ShaderCreationInfo &Info);

	ShaderObj(const ShaderObj &Other)					= delete;
	ShaderObj& operator= (const ShaderObj &Other)		= delete;

	ShaderObj(ShaderObj &&Other);
	ShaderObj& operator= (ShaderObj &&Other);

	bool		Alloc				(const ShaderCreationInfo &Info);
	void		Free				();

	bool		IsUniformAMaterial	(const UniformAttr &Uniform);

	void		Use					();
	void		SetInt				(const char *Uniform, int Value);
	void		SetInt				(const UniformAttr &Uniform);
	void		SetBool				(const char *Uniform, bool Value);
	void		SetBool				(const UniformAttr &Uniform);
	void		SetFloat			(const char *Uniform, float Value);
	void		SetFloat			(const UniformAttr &Uniform);
	void		SetVector			(const char *Uniform, glm::vec2 Value);
	void		SetVector			(const char *Uniform, glm::vec3 Value);
	void		SetVector			(const char *Uniform, glm::vec4 Value);
	void		SetVector			(const UniformAttr &Uniform);
	void		SetMatrix			(const char *Uniform, glm::mat2 Value);
	void		SetMatrix			(const char *Uniform, glm::mat3 Value);
	void		SetMatrix			(const char *Uniform, glm::mat4 Value);
	void		SetMatrix			(const UniformAttr &Uniform);
	void		SetUniform			(const UniformAttr &Uniform);
};